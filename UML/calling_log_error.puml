 @startuml 外呼任务执行全流程 (当前逻辑)
 
  participant "Scheduler" as Sched
  participant "CallingService" as Service
  database "Source Table\n(源工单表)" as SourceDB
  database "Redis" as Redis
  participant "External API\n(外呼接口)" as API
  database "CallHistory\n(历史记录表)" as HistoryDB
  database "CallLog\n(流水日志表)" as LogDB

  autonumber

  note over Sched: 定时任务触发 (Cron)
  Sched -> Service: execute_task_with_config(task_id)
  activate Service

  == Step 1: 读取任务配置 ==
  Service -> Service: 从 DB 读取 CallingTaskConfig
  Service -> Service: 解析字段映射 (JSON)

  == Step 2: 获取待执行号码 (Critical Path) ==
  Service -> SourceDB: SELECT ... FROM SourceDB\nWHERE NOT EXISTS (SELECT 1 FROM HistoryDB)
  note right
    <color:red>潜在问题1: 源表可能有重复号码</color>
    (SQL未做去重，同一个号若有多条工单都会被查出)
    <color:red>潜在问题2: 读写时间差</color>
    (如果任务并发执行，可能两个任务都查到同一个号码)
  end note
  SourceDB --> Service: 返回原始行列表 (Rows)
  Service -> Service: 转换为 CallTask 对象列表 (new_tasks)

  == Step 3: 循环处理与推送 ==
  loop for task in new_tasks
      Service -> Redis: 获取/生成请求体需要的额外参数
      Redis --> Service: 参数

      Service -> API: HTTP POST (推送外呼请求)
      activate API
      API --> Service: Response (Success/Fail)
      deactivate API

      note right
          <color:red>潜在问题3: 重复推送</color>
          (如果 new_tasks 里有重复号，这里会对同一号多次请求)
      end note

      Service -> Service: 记录内存中的结果 (success_tasks, call_logs)
      Service -> Service: sleep(interval)
  end

  == Step 4: 数据回写 (Transaction) ==
  Service -> HistoryDB: begin transaction

  par 批量写入
      Service -> LogDB: INSERT INTO CallLog (所有请求记录)
      Service -> HistoryDB: INSERT INTO CallHistory (成功任务记录)
      note right
          <color:red>严重故障点</color>
          (如果 success_tasks 有重复号，或者DB里已有该号)
          (触发 Unique Constraint Violation)
          (导致整个事务回滚，所有日志丢失)
      end note
  end
  
  HistoryDB --> Service: commit / rollback
  Service -> Service: 记录执行耗时与统计
  deactivate Service
  
   @enduml